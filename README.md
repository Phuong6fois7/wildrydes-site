# AWS Project - Build a Full End-to-End Web Application

## Summary
This project implements a serverless ride-sharing web application on AWS, named Wild Rydes. 
The app simulates a ride-hailing platform similar to Uber, but with a fun twist: users request unicorn rides.

The objective is to design and deploy a full-stack serverless application that demonstrates how multiple AWS services interact seamlessly without managing infrastructure.
The app uses IAM, Amplify, Cognito, Lambda, API Gateway and DynamoDB and with code stored in GitHub. 

## Cost
This architecture guarantees scalability, high availability, and minimal operational costs, fully aligned with the requirements of the “Serverless Track (lowest cost)”.
All services used are part of the AWS Free Tier. While building the application may incur minor charges (typically under $1 USD) outside the Free Tier, costs may continue to accumulate if the app remains active. For instructions on how to remove all deployed resources, please refer to the Teardown section of report.

## The Application Code
The application code is here in this repository.

## The Lambda Function Code
Here is the code for the Lambda function, originally taken from the [AWS workshop](https://aws.amazon.com/getting-started/hands-on/build-serverless-web-app-lambda-apigateway-s3-dynamodb-cognito/module-3/ ), and updated for Node 20.x:

```node
import { randomBytes } from 'crypto';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import { DynamoDBDocumentClient, PutCommand } from '@aws-sdk/lib-dynamodb';

const client = new DynamoDBClient({});
const ddb = DynamoDBDocumentClient.from(client);

const fleet = [
    { Name: 'Angel', Color: 'White', Gender: 'Female' },
    { Name: 'Gil', Color: 'White', Gender: 'Male' },
    { Name: 'Rocinante', Color: 'Yellow', Gender: 'Female' },
];

export const handler = async (event, context) => {
    if (!event.requestContext.authorizer) {
        return errorResponse('Authorization not configured', context.awsRequestId);
    }

    const rideId = toUrlString(randomBytes(16));
    console.log('Received event (', rideId, '): ', event);

    const username = event.requestContext.authorizer.claims['cognito:username'];
    const requestBody = JSON.parse(event.body);
    const pickupLocation = requestBody.PickupLocation;

    const unicorn = findUnicorn(pickupLocation);

    try {
        await recordRide(rideId, username, unicorn);
        return {
            statusCode: 201,
            body: JSON.stringify({
                RideId: rideId,
                Unicorn: unicorn,
                Eta: '30 seconds',
                Rider: username,
            }),
            headers: {
                'Access-Control-Allow-Origin': '*',
            },
        };
    } catch (err) {
        console.error(err);
        return errorResponse(err.message, context.awsRequestId);
    }
};

function findUnicorn(pickupLocation) {
    console.log('Finding unicorn for ', pickupLocation.Latitude, ', ', pickupLocation.Longitude);
    return fleet[Math.floor(Math.random() * fleet.length)];
}

async function recordRide(rideId, username, unicorn) {
    const params = {
        TableName: 'Rides',
        Item: {
            RideId: rideId,
            User: username,
            Unicorn: unicorn,
            RequestTime: new Date().toISOString(),
        },
    };
    await ddb.send(new PutCommand(params));
}

function toUrlString(buffer) {
    return buffer.toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}

function errorResponse(errorMessage, awsRequestId) {
    return {
        statusCode: 500,
        body: JSON.stringify({
            Error: errorMessage,
            Reference: awsRequestId,
        }),
        headers: {
            'Access-Control-Allow-Origin': '*',
        },
    };
}
```

## The Lambda Function Test Function
Here is the code used to test the Lambda function:

```json
{
    "path": "/ride",
    "httpMethod": "POST",
    "headers": {
        "Accept": "*/*",
        "Authorization": "eyJraWQiOiJLTzRVMWZs",
        "content-type": "application/json; charset=UTF-8"
    },
    "queryStringParameters": null,
    "pathParameters": null,
    "requestContext": {
        "authorizer": {
            "claims": {
                "cognito:username": "the_username"
            }
        }
    },
    "body": "{\"PickupLocation\":{\"Latitude\":47.6174755835663,\"Longitude\":-122.28837066650185}}"
}
```

## Deployment
Deployment Steps:

1. Source Code Management – Repository hosted on GitHub

2. Frontend – Deployed via AWS Amplify (connected to GitHub for automatic updates)

3. Authentication – Configured Amazon Cognito User Pool (Region: eu-west-3)

4. Backend Logic – Lambda function created with IAM role for DynamoDB write access

5. Database – DynamoDB table “Rides2025” created

6. API Gateway – REST API set up with /ride resource linked to Lambda

7. Integration – Added Cognito Authorizer and enabled CORS

8. Deployment URL: https://main.d2wfvvhaqsifhc.amplifyapp.com/ride.html

For more details about each service, please refer to the report.

Environment Separation:
Development, testing, and production stages are managed through API Gateway and Amplify environments.
Here, I’ve created only the Dev environment.




